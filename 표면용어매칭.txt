<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>골 표면 용어 매칭 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome 아이콘 사용을 위한 CDN 링크 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f0f4f8;
            color: #1a202c;
        }
        .container {
            background-color: #ffffff;
            border-radius: 2rem;
            box-shadow: 0 20px 50px -12px rgba(0, 0, 0, 0.25);
            transition: transform 0.3s ease-in-out;
            position: relative;
            overflow: hidden;
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
            font-weight: 700;
            transition: all 0.3s ease-in-out;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-primary:hover {
            background-color: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .card {
            background-color: #e0f2fe;
            border: 2px solid #93c5fd;
            border-radius: 1rem;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .card:hover:not(.matched) {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .card.selected {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }
        .card.matched {
            border-color: #22c55e;
            background-color: #22c55e;
            color: white;
            cursor: default;
            animation: match-pulse 0.5s ease-in-out forwards;
        }
        .card.mismatched {
            animation: shake 0.5s;
            border-color: #ef4444;
        }
        .results {
            animation: fadeIn 0.8s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes match-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes shake {
            0% { transform: translateX(0); }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }
        /* 꽃가루 애니메이션 스타일 */
        .pollen-particle {
            position: absolute;
            background-color: #fde047;
            border-radius: 50%;
            width: 8px;
            height: 8px;
            opacity: 0;
            animation: fly-pollen 1.5s forwards;
            pointer-events: none;
        }
        
        @keyframes fly-pollen {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-200px) rotate(720deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <div class="container w-full max-w-2xl p-8 md:p-12 text-center">
        <h1 class="text-3xl md:text-4xl font-extrabold mb-6 text-blue-800">골 표면 용어 매칭 게임</h1>
        
        <div id="game-screen">
            <div id="game-board" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
                <!-- 카드들이 여기에 동적으로 삽입됩니다 -->
            </div>

            <div id="status-message" class="text-xl font-bold mb-4"></div>
            
            <button id="restart-button" class="btn-primary w-full hidden">
                <span>다시 시작</span>
                <i class="fas fa-redo-alt ml-2"></i>
            </button>
        </div>
    </div>

    <script>
        const terms = {
            "돌출 부위": [
                { term: "돌기(process)", definition: "골표면에서 뚜렷하게 돌출된 부위" },
                { term: "융기(eminence)", definition: "골표면에 있는 둥근 형태로 완만하게 높아진 부분" },
                { term: "두(머리, head)", definition: "둥근 형태의 표면으로 관절면을 가지고 있는 돌기" },
                { term: "경(목, neck)", definition: "두에서 이어지는 좁은 부분" },
                { term: "결절(tubercle)", definition: "대나무 마디처럼 작고 둥근 형태의 튀어나온 부위" },
                { term: "조면(거친면, tuberosity)", definition: "골표면에 나타나는 크고 거친 면을 가진 부분" },
                { term: "각(뿔, horn)", definition: "소뿔 형태의 작은 융기" },
                { term: "소설(혀돌기, lingula)", definition: "혀 모양처럼 튀어나온 부위" },
                { term: "능(능선, crest)", definition: "골표면에 있는 능선처럼 길게 융기된 부분" },
                { term: "선(line)", definition: "골에 있는 직선형, 선 모양으로 튀어나온 부위" },
                { term: "극(가시, spine)", definition: "작고 가시처럼 확연히 돌출된 부위" }
            ],
            "함몰 부위": [
                { term: "절흔(패임, notch)", definition: "도려낸 것처럼 움푹 파인 부위" },
                { term: "구(고랑, groove)", definition: "골표면에 있는 가늘고 긴 고랑" },
                { term: "와(오목, fossa)", definition: "골표면에 위치한 얕고 오목한 부위" },
                { term: "소와(작은오목, pit)", definition: "골표면에 파낸 것 같은 오목한 부위" }
            ],
            "구멍": [
                { term: "공(구멍, foramen)", definition: "골표면에 구멍이 뚫린 부위" },
                { term: "관(canal)", definition: "좁고 긴 튜브 형태의 관" },
                { term: "도(길, meatus)", definition: "골에 위치한 개구부나 통로" },
                { term: "열(틈새, fissure)", definition: "골에 위치한 갈라진 형태의 좁은 틈" },
                { term: "강(공간, cavity)", definition: "여러 종류의 골로 둘러싸여 형성된 공간" },
                { term: "동(동굴, sinus)", definition: "한 종류의 골 속에 있는 빈 공간" }
            ],
            "기타": [
                { term: "궁(활, arch)", definition: "활 모양의 얇게 두드러진 골 구조물" },
                { term: "관절(joint)", definition: "2개의 서로 다른 골이 만나는 부위" },
                { term: "판(plate)", definition: "편평하고 얇은 형태의 부위" },
                { term: "봉합(suture)", definition: "섬유성 관절의 일종으로 양쪽 골이 맞물려 움직이지 않게 고정된 관절" }
            ]
        };

        const boardSize = 16; // 8쌍의 카드 (16개)

        let allPairs = [];
        let shuffledCards = [];
        let selectedCards = [];
        let matchesFound = 0;
        let isLocked = false;

        const container = document.querySelector('.container');
        const gameBoard = document.getElementById('game-board');
        const statusMessage = document.getElementById('status-message');
        const restartButton = document.getElementById('restart-button');

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createPollenEffect(sourceElement) {
            const rect = sourceElement.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const sourceX = rect.left + rect.width / 2 - containerRect.left;
            const sourceY = rect.top + rect.height / 2 - containerRect.top;

            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.classList.add('pollen-particle');
                container.appendChild(particle);

                const angle = Math.random() * 2 * Math.PI;
                const distance = Math.random() * 150 + 50;
                const finalX = sourceX + distance * Math.cos(angle);
                const finalY = sourceY - distance * Math.sin(angle);

                particle.style.left = `${sourceX}px`;
                particle.style.top = `${sourceY}px`;
                particle.style.transform = `translate(${finalX - sourceX}px, ${finalY - sourceY}px) rotate(${Math.random() * 360}deg)`;
                
                setTimeout(() => {
                    particle.remove();
                }, 1500);
            }
        }
        
        function initializeGame() {
            // 모든 용어-정의 쌍을 가져와서 섞기
            let tempAllTerms = [];
            for (const key in terms) {
                tempAllTerms = tempAllTerms.concat(terms[key]);
            }
            const allShuffledTerms = shuffle(tempAllTerms);
            
            // 보드 크기에 맞는 용어 쌍 선택
            allPairs = allShuffledTerms.slice(0, boardSize / 2);
            
            // 용어 카드와 정의 카드를 분리
            let termCards = allPairs.map(item => ({ type: 'term', value: item.term, pair: item.definition }));
            let definitionCards = allPairs.map(item => ({ type: 'definition', value: item.definition, pair: item.term }));
            
            shuffledCards = shuffle([...termCards, ...definitionCards]);
            
            selectedCards = [];
            matchesFound = 0;
            isLocked = false;
            
            gameBoard.innerHTML = '';
            restartButton.classList.add('hidden');
            statusMessage.textContent = '카드를 두 개씩 뒤집어 짝을 맞춰보세요!';

            shuffledCards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('card');
                cardElement.dataset.index = index;
                cardElement.textContent = card.value;
                cardElement.addEventListener('click', () => handleCardClick(cardElement, card));
                gameBoard.appendChild(cardElement);
            });
        }
        
        function handleCardClick(cardElement, cardData) {
            if (isLocked || cardElement.classList.contains('selected') || cardElement.classList.contains('matched')) {
                return;
            }

            cardElement.classList.add('selected');
            selectedCards.push({ element: cardElement, data: cardData });

            if (selectedCards.length === 2) {
                isLocked = true;
                const [card1, card2] = selectedCards;

                if (card1.data.pair === card2.data.value) {
                    // 일치하는 경우
                    setTimeout(() => {
                        card1.element.classList.add('matched');
                        card2.element.classList.add('matched');
                        createPollenEffect(card1.element);
                        createPollenEffect(card2.element);
                        
                        matchesFound++;
                        selectedCards = [];
                        isLocked = false;
                        statusMessage.textContent = `축하합니다! ${matchesFound}/${boardSize / 2}개 짝을 맞혔어요.`;
                        
                        if (matchesFound === boardSize / 2) {
                            endGame();
                        }
                    }, 500);
                } else {
                    // 불일치하는 경우
                    card1.element.classList.add('mismatched');
                    card2.element.classList.add('mismatched');
                    
                    setTimeout(() => {
                        card1.element.classList.remove('selected', 'mismatched');
                        card2.element.classList.remove('selected', 'mismatched');
                        selectedCards = [];
                        isLocked = false;
                        statusMessage.textContent = '아쉽네요. 다시 시도해 보세요!';
                    }, 1000);
                }
            }
        }
        
        function endGame() {
            statusMessage.textContent = "모든 짝을 완벽하게 맞혔어요!";
            restartButton.classList.remove('hidden');
        }

        restartButton.addEventListener('click', () => {
            initializeGame();
        });

        initializeGame();
    </script>
</body>
</html>
