<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>치위생과 해부학 용어 플래시카드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }

        .flashcard-container {
            perspective: 1000px;
        }

        .flashcard {
            width: 100%;
            height: 400px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.8s;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .flashcard-front {
            background: linear-gradient(135deg, #f0f9ff, #cbe3f2);
            color: #1e40af;
            z-index: 2;
        }

        .flashcard-back {
            background: linear-gradient(135deg, #fdf6f3, #e8d0c8);
            color: #8c4228;
            transform: rotateY(180deg);
            z-index: 1;
        }
        
        .question-text {
            font-size: 1.5rem;
            font-weight: 700;
            text-align: center;
            line-height: 1.4;
        }

        .answer-text {
            font-size: 1.2rem;
            font-weight: 400;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .rationale-text {
            font-size: 1rem;
            color: #4b5563;
        }

        .option-button {
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 700;
            margin: 0.5rem 0;
            width: 100%;
            max-width: 320px;
        }
        .option-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        .correct-answer {
            background-color: #d1fae5;
            color: #10b981;
        }

        .incorrect-answer {
            background-color: #fee2e2;
            color: #ef4444;
        }
    </style>
</head>
<body class="bg-gray-50 flex items-center justify-center min-h-screen p-4">

<div class="bg-white rounded-3xl shadow-xl max-w-2xl w-full p-8 space-y-6">
    <div class="text-center space-y-2">
        <h1 class="text-3xl font-bold text-gray-800">해부학 용어 플래시카드</h1>
        <p class="text-gray-500 text-lg">골의 표면구조 용어를 학습해 보세요</p>
    </div>

    <div id="quiz-container" class="space-y-6">
        <div class="flex justify-between items-center text-gray-600 font-medium">
            <span id="question-count">1/10</span>
            <span id="hint-text"></span>
        </div>

        <div class="flashcard-container">
            <div id="flashcard" class="flashcard">
                <div class="flashcard-face flashcard-front">
                    <p id="question-text" class="question-text"></p>
                </div>
                <div class="flashcard-face flashcard-back flex-col items-start justify-start text-left">
                    <div class="space-y-2">
                        <p id="answer-text" class="answer-text font-bold"></p>
                        <p id="rationale-text" class="rationale-text"></p>
                    </div>
                </div>
            </div>
        </div>

        <div id="options-container" class="flex flex-col items-center space-y-2"></div>
        
        <div id="navigation-buttons" class="flex justify-between gap-4 mt-6">
            <button id="previous-btn" class="flex-1 py-3 px-6 rounded-full bg-gray-200 text-gray-700 font-bold hover:bg-gray-300 transition-colors">이전</button>
            <button id="next-btn" class="flex-1 py-3 px-6 rounded-full bg-blue-500 text-white font-bold hover:bg-blue-600 transition-colors shadow-lg">다음</button>
        </div>
        
        <div id="reset-button-container" class="flex justify-center mt-4 hidden">
            <button id="reset-btn" class="py-3 px-8 rounded-full bg-green-500 text-white font-bold hover:bg-green-600 transition-colors shadow-lg">다시 시작</button>
        </div>
    </div>
</div>

<script>
    const quizData = [
        { "question": "골표면에서 뚜렷하게 돌출된 부위를 지칭하는 해부학 용어는 무엇인가요?", "hint": "관절을 형성하는 둥근 돌기와는 다른 일반적인 돌출 부위입니다.", "options": [ { "text": "융기 (eminence)", "isCorrect": false, "rationale": "융기는 골표면에 둥근 형태로 완만하게 높아진 부분입니다. 뚜렷하게 돌출된 부위와는 차이가 있습니다." }, { "text": "돌기 (process)", "isCorrect": true, "rationale": "돌기는 골표면에서 뚜렷하게 돌출된 부위를 의미하는 정확한 용어입니다." }, { "text": "결절 (tubercle)", "isCorrect": false, "rationale": "결절은 작고 둥근 형태로 튀어나온 부위로, 모든 돌출 부위에 사용되는 용어는 아닙니다." }, { "text": "조면 (tuberosity)", "isCorrect": false, "rationale": "조면은 크고 거친 면을 가진 부분으로, 돌출의 형태보다는 표면의 질감을 설명하는 용어입니다." } ] },
        { "question": "골표면에 있는 가늘고 긴 고랑을 뜻하는 용어는 무엇인가요?", "hint": "배수로처럼 길게 파여 있는 형태를 연상해 보세요.", "options": [ { "text": "절흔 (notch)", "isCorrect": false, "rationale": "절흔은 도려낸 것처럼 움푹 파인 부위입니다." }, { "text": "와 (fossa)", "isCorrect": false, "rationale": "와는 얕고 오목한 부위를 뜻하는 용어입니다." }, { "text": "구 (groove)", "isCorrect": true, "rationale": "구는 골표면에 있는 가늘고 긴 고랑을 정확하게 의미하는 용어입니다." }, { "text": "소와 (pit)", "isCorrect": false, "rationale": "소와는 골표면에 파낸 것 같은 작은 오목한 부위를 뜻합니다." } ] },
        { "question": "골표면에 구멍이 뚫린 부위를 지칭하는 해부학 용어는 무엇인가요?", "hint": "신경이나 혈관이 통과하는 통로의 입구입니다.", "options": [ { "text": "관 (canal)", "isCorrect": false, "rationale": "관은 좁고 긴 튜브 형태의 관을 의미합니다." }, { "text": "도 (meatus)", "isCorrect": false, "rationale": "도는 골에 위치한 개구부나 통로를 의미합니다." }, { "text": "열 (fissure)", "isCorrect": false, "rationale": "열은 골에 위치한 갈라진 형태의 좁은 틈을 의미합니다." }, { "text": "공 (foramen)", "isCorrect": true, "rationale": "공은 골표면에 구멍이 뚫린 부위를 지칭하는 올바른 용어입니다." } ] },
        { "question": "소뿔 형태의 작은 융기를 뜻하는 용어는 무엇인가요?", "hint": "동물의 뿔을 뜻하는 한자어입니다.", "options": [ { "text": "각 (horn)", "isCorrect": true, "rationale": "각은 소뿔 형태의 작은 융기를 정확하게 의미합니다." }, { "text": "결절 (tubercle)", "isCorrect": false, "rationale": "결절은 대나무 마디처럼 작고 둥근 튀어나온 부위입니다." }, { "text": "소설 (lingula)", "isCorrect": false, "rationale": "소설은 혀 모양처럼 튀어나온 부위입니다." }, { "text": "극 (spine)", "isCorrect": false, "rationale": "극은 작고 가시처럼 확연히 돌출된 부위입니다." } ] },
        { "question": "둥근 형태의 표면으로 관절면을 가지고 있는 돌기를 무엇이라고 하나요?", "hint": "인체에서 가장 높은 곳에 있는 기관을 뜻하는 단어와 발음이 비슷합니다.", "options": [ { "text": "경 (neck)", "isCorrect": false, "rationale": "경은 두에서 이어지는 좁은 부분입니다." }, { "text": "두 (head)", "isCorrect": true, "rationale": "두는 둥근 형태의 표면으로 관절면을 가지고 있는 돌기를 정확하게 의미합니다." }, { "text": "융기 (eminence)", "isCorrect": false, "rationale": "융기는 골표면에 있는 둥근 형태로 완만하게 높아진 부분입니다." }, { "text": "결절 (tubercle)", "isCorrect": false, "rationale": "결절은 작고 둥근 형태로 튀어나온 부위입니다." } ] },
        { "question": "골에 있는 직선형, 선 모양으로 튀어나온 부위를 뜻하는 용어는 무엇인가요?", "hint": "우리가 종이에 그리는 것과 같은 형태입니다.", "options": [ { "text": "능 (crest)", "isCorrect": false, "rationale": "능은 능선처럼 길게 융기된 부분입니다." }, { "text": "선 (line)", "isCorrect": true, "rationale": "선은 골에 있는 직선형, 선 모양으로 튀어나온 부위를 정확하게 의미합니다." }, { "text": "극 (spine)", "isCorrect": false, "rationale": "극은 작고 가시처럼 확연히 돌출된 부위입니다." }, { "text": "소설 (lingula)", "isCorrect": false, "rationale": "소설은 혀 모양처럼 튀어나온 부위입니다." } ] },
        { "question": "뼈가 갈라진 것처럼 좁은 틈이 있는 부위를 뜻하는 용어는 무엇인가요?", "hint": "골절이나 균열의 형태와 유사합니다.", "options": [ { "text": "강 (cavity)", "isCorrect": false, "rationale": "강은 여러 종류의 골로 둘러싸여 형성된 공간을 의미합니다." }, { "text": "동 (sinus)", "isCorrect": false, "rationale": "동은 한 종류의 골 속에 있는 빈 공간입니다." }, { "text": "열 (fissure)", "isCorrect": true, "rationale": "열은 골에 위치한 갈라진 형태의 좁은 틈을 의미하는 정확한 용어입니다." }, { "text": "관 (canal)", "isCorrect": false, "rationale": "관은 좁고 긴 튜브 형태의 관을 의미합니다." } ] },
        { "question": "골표면에 위치한 얕고 오목한 부위를 지칭하는 용어는 무엇인가요?", "hint": "라틴어로 '웅덩이'나 '구덩이'를 뜻하는 단어에서 유래했습니다.", "options": [ { "text": "절흔 (notch)", "isCorrect": false, "rationale": "절흔은 도려낸 것처럼 움푹 파인 부위입니다." }, { "text": "구 (groove)", "isCorrect": false, "rationale": "구는 골표면에 있는 가늘고 긴 고랑을 의미합니다." }, { "text": "와 (fossa)", "isCorrect": true, "rationale": "와는 골표면에 위치한 얕고 오목한 부위를 정확하게 의미하는 용어입니다." }, { "text": "소와 (pit)", "isCorrect": false, "rationale": "소와는 골표면에 파낸 것 같은 오목한 부위를 뜻합니다." } ] },
        { "question": "활 모양의 얇게 두드러진 골 구조물을 뜻하는 용어는 무엇인가요?", "hint": "로마 건축물에서 자주 볼 수 있는 구조와 형태가 비슷합니다.", "options": [ { "text": "궁 (arch)", "isCorrect": true, "rationale": "궁은 활 모양의 얇게 두드러진 골 구조물을 정확하게 의미하는 용어입니다." }, { "text": "관절 (joint)", "isCorrect": false, "rationale": "관절은 두 개의 서로 다른 골이 만나는 부위입니다." }, { "text": "판 (plate)", "isCorrect": false, "rationale": "판은 편평하고 얇은 형태의 부위입니다." }, { "text": "봉합 (suture)", "isCorrect": false, "rationale": "봉합은 양쪽 골이 맞물려 움직이지 않게 고정된 관절입니다." } ] },
        { "question": "여러 종류의 뼈로 둘러싸여 형성된 공간을 지칭하는 용어는 무엇인가요?", "hint": "몸 안에 있는 비어있는 공간을 뜻하는 일반적인 단어입니다.", "options": [ { "text": "도 (meatus)", "isCorrect": false, "rationale": "도는 골에 위치한 개구부나 통로를 의미합니다." }, { "text": "열 (fissure)", "isCorrect": false, "rationale": "열은 골에 위치한 갈라진 형태의 좁은 틈을 의미합니다." }, { "text": "강 (cavity)", "isCorrect": true, "rationale": "강은 여러 종류의 골로 둘러싸여 형성된 공간을 의미하는 정확한 용어입니다." }, { "text": "동 (sinus)", "isCorrect": false, "rationale": "동은 한 종류의 골 속에 있는 빈 공간을 의미합니다." } ] }
    ];

    let currentQuestionIndex = 0;
    let answered = false;
    const flashcard = document.getElementById('flashcard');
    const questionText = document.getElementById('question-text');
    const answerText = document.getElementById('answer-text');
    const rationaleText = document.getElementById('rationale-text');
    const optionsContainer = document.getElementById('options-container');
    const questionCount = document.getElementById('question-count');
    const hintText = document.getElementById('hint-text');
    const nextBtn = document.getElementById('next-btn');
    const previousBtn = document.getElementById('previous-btn');
    const resetBtn = document.getElementById('reset-btn');
    const resetButtonContainer = document.getElementById('reset-button-container');

    function showQuestion(index) {
        if (flashcard.classList.contains('flipped')) {
            flashcard.classList.remove('flipped');
        }
        answered = false;
        optionsContainer.innerHTML = '';
        const currentQuestion = quizData[index];
        questionText.textContent = currentQuestion.question;
        hintText.textContent = currentQuestion.hint;
        questionCount.textContent = `${index + 1}/${quizData.length}`;

        currentQuestion.options.forEach(option => {
            const button = document.createElement('button');
            button.textContent = option.text;
            button.classList.add('option-button', 'bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
            button.addEventListener('click', () => {
                if (!answered) {
                    checkAnswer(option);
                }
            });
            optionsContainer.appendChild(button);
        });

        updateNavigationButtons();
    }

    function checkAnswer(selectedOption) {
        answered = true;
        flashcard.classList.add('flipped');

        answerText.textContent = selectedOption.text;
        rationaleText.textContent = selectedOption.rationale;

        const optionButtons = optionsContainer.querySelectorAll('.option-button');
        optionButtons.forEach(button => {
            const isCorrect = quizData[currentQuestionIndex].options.find(opt => opt.text === button.textContent).isCorrect;
            button.disabled = true;
            if (isCorrect) {
                button.classList.add('correct-answer');
                button.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700');
            } else if (button.textContent === selectedOption.text) {
                button.classList.add('incorrect-answer');
                button.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700');
            } else {
                button.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-700');
                button.classList.add('bg-gray-100', 'text-gray-400', 'cursor-not-allowed');
            }
        });
    }

    function updateNavigationButtons() {
        previousBtn.disabled = currentQuestionIndex === 0;
        previousBtn.classList.toggle('opacity-50', currentQuestionIndex === 0);
        
        nextBtn.textContent = (currentQuestionIndex === quizData.length - 1) ? '결과 보기' : '다음';
        resetButtonContainer.classList.add('hidden');
    }

    nextBtn.addEventListener('click', () => {
        if (answered && currentQuestionIndex < quizData.length - 1) {
            currentQuestionIndex++;
            showQuestion(currentQuestionIndex);
        } else if (answered && currentQuestionIndex === quizData.length - 1) {
            // End of quiz, show a message or the reset button
            showFinalMessage();
        }
    });

    previousBtn.addEventListener('click', () => {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            showQuestion(currentQuestionIndex);
        }
    });

    function showFinalMessage() {
        flashcard.classList.remove('flipped');
        questionText.innerHTML = `퀴즈 완료! <br> 수고하셨습니다.`;
        hintText.textContent = '';
        optionsContainer.innerHTML = '';
        nextBtn.style.display = 'none';
        previousBtn.style.display = 'none';
        resetButtonContainer.classList.remove('hidden');
    }

    resetBtn.addEventListener('click', () => {
        currentQuestionIndex = 0;
        nextBtn.style.display = 'block';
        previousBtn.style.display = 'block';
        showQuestion(currentQuestionIndex);
    });

    // Initial load
    window.onload = () => {
        showQuestion(currentQuestionIndex);
    };
</script>

</body>
</html>
